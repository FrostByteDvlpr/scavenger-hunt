<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Word Chase AR</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
  
  <style>
    body, html {
      margin: 0; 
      padding: 0;
      overflow: hidden;
      font-family: 'Comic Sans MS', 'Poppins', sans-serif;
      background: transparent !important;
      touch-action: manipulation;
    }
    
    #cameraView {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 0;
    }
    
    #cameraVideo {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }
    
    #loadingScreen {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 1000;
      color: white;
      text-align: center;
    }
    
    #loadingScreen h1 {
      font-size: 2.5rem;
      margin-bottom: 20px;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
    }
    
    #loadingScreen p {
      font-size: 1.2rem;
      margin: 10px 0;
    }
    
    #startButton {
      background: #ff69b4;
      color: white;
      border: none;
      padding: 15px 30px;
      font-size: 1.3rem;
      border-radius: 25px;
      margin-top: 20px;
      cursor: pointer;
      box-shadow: 0 4px 15px rgba(0,0,0,0.3);
    }
    
    /* Floating letters overlay */
    .floating-letter {
      position: fixed;
      background: rgba(0, 0, 0, 0.8);
      color: #FFD700;
      font-size: 3rem;
      font-weight: bold;
      padding: 15px 20px;
      border-radius: 15px;
      border: 3px solid #FFD700;
      cursor: pointer;
      z-index: 5;
      transform-origin: center;
      transition: all 0.2s ease;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
      box-shadow: 0 0 20px rgba(255, 215, 0, 0.3);
    }
    
    .floating-letter:hover {
      transform: scale(1.2);
      box-shadow: 0 0 30px rgba(255, 215, 0, 0.5);
    }
    
    .floating-letter.targeted {
      border-color: #00ff00 !important;
      color: #00ff00 !important;
      background: rgba(0, 255, 0, 0.2) !important;
      box-shadow: 0 0 40px rgba(0, 255, 0, 0.8) !important;
      animation: targetedPulse 0.8s ease-in-out infinite;
    }
    
    @keyframes targetedPulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.1); }
    }
    
    .floating-letter.captured {
      background: rgba(0, 150, 0, 0.8);
      color: #00FF00;
      border-color: #00FF00;
      animation: captureAnimation 1s ease-out;
    }
    
    @keyframes captureAnimation {
      0% { transform: scale(1); }
      50% { transform: scale(2) rotate(180deg); }
      100% { transform: scale(0) rotate(360deg); opacity: 0; }
    }
    
    @keyframes float {
      0%, 100% { transform: translateY(0px) rotate(0deg); }
      25% { transform: translateY(-10px) rotate(5deg); }
      50% { transform: translateY(-5px) rotate(-5deg); }
      75% { transform: translateY(-15px) rotate(2deg); }
    }
    
    #wordDisplay {
      position: fixed;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(255,255,255,0.95);
      padding: 15px 25px;
      border-radius: 15px;
      font-size: 1.8rem;
      z-index: 10;
      border: 3px solid #000;
      font-weight: bold;
      display: none;
    }
    
    #captureButton {
      position: fixed;
      bottom: 40px;
      left: 50%;
      transform: translateX(-50%);
      background-color: #ff69b4;
      color: white;
      font-size: 2rem;
      border: none;
      border-radius: 50px;
      padding: 20px 40px;
      cursor: pointer;
      z-index: 999;
      box-shadow: 0 4px 10px rgba(0,0,0,0.3);
      transition: all 0.3s ease;
    }
    #captureButton.ready {
      background-color: #00ff00;
      animation: pulse 1s ease-in-out infinite;
    }
    @keyframes pulse {
      0%, 100% { transform: translateX(-50%) scale(1); }
      50% { transform: translateX(-50%) scale(1.05); }
    }
    #crosshair {
      position: fixed;
      top: 50%;
      left: 50%;
      width: 60px;
      height: 60px;
      transform: translate(-50%, -50%);
      border: 3px solid rgba(255, 255, 255, 0.9);
      border-radius: 50%;
      z-index: 500;
      pointer-events: none;
      transition: all 0.2s ease;
      box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
    }
    #crosshair::before {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      width: 24px;
      height: 3px;
      background: rgba(255, 255, 255, 0.9);
      transform: translate(-50%, -50%);
      box-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
    }
    #crosshair::after {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      width: 3px;
      height: 24px;
      background: rgba(255, 255, 255, 0.9);
      transform: translate(-50%, -50%);
      box-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
    }
    #crosshair.target-locked {
      border-color: #00ff00;
      box-shadow: 0 0 20px rgba(0, 255, 0, 0.6);
      animation: targetPulse 0.5s ease-in-out infinite;
    }
    #crosshair.target-locked::before,
    #crosshair.target-locked::after {
      background: #00ff00;
    }
    @keyframes targetPulse {
      0%, 100% { transform: translate(-50%, -50%) scale(1); }
      50% { transform: translate(-50%, -50%) scale(1.2); }
    }
    #win-message {
      position: fixed;
      top: 40%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(255,255,255,0.9);
      color: #333;
      font-size: 2.5rem;
      padding: 30px;
      border-radius: 20px;
      display: none;
    }
    
    #instructions {
      position: fixed;
      bottom: 120px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0,0,0,0.8);
      color: white;
      padding: 15px 25px;
      border-radius: 10px;
      z-index: 10;
      text-align: center;
      font-size: 1.1rem;
      display: none;
      max-width: 90%;
    }
    
    #compass {
      position: fixed;
      top: 80px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0,0,0,0.8);
      color: white;
      padding: 8px 15px;
      border-radius: 20px;
      z-index: 10;
      font-size: 14px;
      text-align: center;
      display: none;
    }
    
    #debugInfo {
      position: fixed;
      bottom: 20px;
      right: 20px;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 10px;
      border-radius: 5px;
      z-index: 10;
      font-size: 11px;
      max-width: 200px;
      display: none;
    }
  </style>
</head>

<body>
  <!-- Loading Screen -->
  <div id="loadingScreen">
    <h1>üéØ Word Chase AR</h1>
    <p>Get ready to hunt for letters!</p>
    <p>Move your phone around to find letters</p>
    <p>Tap the letters to capture them!</p>
    <button id="startButton">Start Letter Hunt</button>
  </div>

  <!-- Camera View -->
  <div id="cameraView" style="display: none;">
    <video id="cameraVideo" autoplay playsinline muted></video>
  </div>

  <!-- Game UI -->
  <div id="wordDisplay">Find: <strong id="targetWord">BIKE</strong></div>
  <div id="instructions">üëÜ Swipe to look around ‚Ä¢ üéØ Center crosshair on letters<br>The button turns green when ready to capture.</div>
  <div id="compass">üìç Turn around to find letters</div>
  <div id="debugInfo">Starting camera...</div>
  <div id="crosshair"></div>
  <button id="captureButton">üéØ Capture!</button>

  <script>
    const targetWord = "BIKE";
    const captured = [];
    let gameStarted = false;
    let letters = [];
    
    // Touch/swipe tracking for camera movement
    let cameraRotation = { x: 0, y: 0 }; // Current camera rotation
    let touchStart = { x: 0, y: 0 };
    let isDragging = false;
    
    let debugInfo = document.getElementById('debugInfo');
    
    function updateDebug(message) {
      console.log(message);
      if (debugInfo) {
        debugInfo.innerHTML = message;
      }
    }
    
    function updateDebugInfo() {
      // Update compass
      const compass = document.getElementById('compass');
      if (compass) {
        const visibleLetters = letters.filter(l => 
          !captured.includes(l.index) && 
          l.element.style.display !== 'none'
        );
        
        if (visibleLetters.length > 0) {
          compass.textContent = `üìç Visible: ${visibleLetters.map(l => l.letter).join(', ')}`;
        } else {
          compass.textContent = "üîÑ Swipe to look around for letters";
        }
      }
      
      // Update debug info
      if (debugInfo) {
        let debugText = `Camera Y: ${(cameraRotation.y * 180 / Math.PI).toFixed(1)}¬∞<br>`;
        debugText += `Camera X: ${(cameraRotation.x * 180 / Math.PI).toFixed(1)}¬∞<br><br>`;
        
        const visibleLetters = letters.filter(l => 
          !captured.includes(l.index) && 
          l.element.style.display !== 'none'
        );
        
        debugText += `Visible: ${visibleLetters.map(l => l.letter).join(', ')}<br>`;
        
        const target = getTargetedLetter();
        if (target) {
          debugText += `Targeted: ${target.letterData.letter} (${target.distance.toFixed(0)}px)`;
        } else {
          debugText += 'No target';
        }
        
        debugInfo.innerHTML = debugText;
      }
    }

    // Start button handler
    document.getElementById('startButton').addEventListener('click', function() {
      startCameraExperience();
    });

    async function startCameraExperience() {
      updateDebug('Starting camera...');
      
      try {
        // Request device orientation permission on iOS
        if (typeof DeviceOrientationEvent.requestPermission === 'function') {
          const permission = await DeviceOrientationEvent.requestPermission();
          if (permission !== 'granted') {
            throw new Error('Device orientation permission denied');
          }
        }
        
        const stream = await navigator.mediaDevices.getUserMedia({ 
          video: { 
            facingMode: 'environment',
            width: { ideal: 1280 },
            height: { ideal: 720 }
          } 
        });
        
        const video = document.getElementById('cameraVideo');
        video.srcObject = stream;
        
        // Hide loading screen and show camera
        document.getElementById('loadingScreen').style.display = 'none';
        document.getElementById('cameraView').style.display = 'block';
        document.getElementById('wordDisplay').style.display = 'block';
        document.getElementById('captureButton').style.display = 'block';
        document.getElementById('instructions').style.display = 'block';
        document.getElementById('compass').style.display = 'block';
        document.getElementById('debugInfo').style.display = 'block';
        
        updateDebug('Camera started!');
        
        // Set up touch controls for camera movement
        setupTouchControls();
        
        // Start the letter hunt
        setTimeout(() => {
          createFloatingLetters();
        }, 1000);

      } catch (error) {
        console.error('Camera failed:', error);
        updateDebug('Camera failed: ' + error.message);
        
        document.getElementById('loadingScreen').innerHTML = `
          <h1>‚ö†Ô∏è Camera Access Required</h1>
          <p>Please allow camera access and try again</p>
          <button onclick="location.reload()">Retry</button>
        `;
      }
    }

    function setupTouchControls() {
      const cameraView = document.getElementById('cameraView');
      
      // Touch start
      cameraView.addEventListener('touchstart', function(e) {
        if (e.touches.length === 1) {
          isDragging = true;
          touchStart.x = e.touches[0].clientX;
          touchStart.y = e.touches[0].clientY;
        }
      });
      
      // Touch move - rotate camera
      cameraView.addEventListener('touchmove', function(e) {
        if (isDragging && e.touches.length === 1) {
          e.preventDefault();
          
          const deltaX = e.touches[0].clientX - touchStart.x;
          const deltaY = e.touches[0].clientY - touchStart.y;
          
          // Convert touch movement to camera rotation
          // Sensitivity: adjust these values to make movement faster/slower
          cameraRotation.y -= deltaX * 0.01; // Horizontal rotation (left/right)
          cameraRotation.x -= deltaY * 0.01; // Vertical rotation (up/down)
          
          // Limit vertical rotation to prevent flipping
          cameraRotation.x = Math.max(-Math.PI/3, Math.min(Math.PI/3, cameraRotation.x));
          
          updateLetterPositions();
          
          // Update touch start position for smooth continuous movement
          touchStart.x = e.touches[0].clientX;
          touchStart.y = e.touches[0].clientY;
        }
      });
      
      // Touch end
      cameraView.addEventListener('touchend', function(e) {
        isDragging = false;
      });
      
      // Mouse support for desktop testing
      cameraView.addEventListener('mousedown', function(e) {
        isDragging = true;
        touchStart.x = e.clientX;
        touchStart.y = e.clientY;
      });
      
      cameraView.addEventListener('mousemove', function(e) {
        if (isDragging) {
          e.preventDefault();
          
          const deltaX = e.clientX - touchStart.x;
          const deltaY = e.clientY - touchStart.y;
          
          cameraRotation.y -= deltaX * 0.01;
          cameraRotation.x -= deltaY * 0.01;
          cameraRotation.x = Math.max(-Math.PI/3, Math.min(Math.PI/3, cameraRotation.x));
          
          updateLetterPositions();
          
          touchStart.x = e.clientX;
          touchStart.y = e.clientY;
        }
      });
      
      cameraView.addEventListener('mouseup', function(e) {
        isDragging = false;
      });
      
      updateDebug('Touch controls initialized');
      // Start updating positions immediately
      updateLetterPositions();
    }

    function createFloatingLetters() {
      updateDebug('Creating floating letters...');
      
      // Remove any existing letters
      letters.forEach(letter => {
        if (letter.element && letter.element.parentNode) {
          letter.element.parentNode.removeChild(letter.element);
        }
      });
      letters = [];
      
      // Create letters with 3D-like positioning
      for (let i = 0; i < targetWord.length; i++) {
        const letter = targetWord[i];
        const letterElement = document.createElement('div');
        letterElement.className = 'floating-letter';
        letterElement.textContent = letter;
        letterElement.setAttribute('data-letter', letter);
        letterElement.setAttribute('data-index', i);
        
        // Give each letter a 3D world position
        const letterData = {
          letter: letter,
          index: i,
          element: letterElement,
          // 3D world coordinates - place letters in a semicircle around the player
          worldX: Math.cos(i * Math.PI / 2) * 300, // Semicircle distribution
          worldY: (i - 1.5) * 60, // Vary height slightly
          worldZ: -Math.sin(i * Math.PI / 2) * 300 - 200, // Semicircle depth
          baseWorldX: Math.cos(i * Math.PI / 2) * 300,
          baseWorldY: (i - 1.5) * 60,
          baseWorldZ: -Math.sin(i * Math.PI / 2) * 300 - 200
        };
        
        // Remove click handlers - letters can only be captured through targeting
        
        document.body.appendChild(letterElement);
        letters.push(letterData);
        
        updateDebug(`Added letter ${letter}`);
      }
      
      updateDebug(`Created ${letters.length} floating letters`);
      
      // Start with camera slightly turned to show first letter
      cameraRotation.y = -0.3; // Turn left slightly to show letters
      updateLetterPositions();
    }

    function updateLetterPositions() {
      if (letters.length === 0) return;
      
      letters.forEach(letterData => {
        if (!letterData.element.parentNode) return;
        
        // Apply camera rotation to world coordinates
        let x = letterData.baseWorldX;
        let y = letterData.baseWorldY;
        let z = letterData.baseWorldZ;
        
        // Rotate around Y axis (horizontal camera rotation)
        const cosY = Math.cos(cameraRotation.y);
        const sinY = Math.sin(cameraRotation.y);
        const rotatedX = x * cosY - z * sinY;
        const rotatedZ = x * sinY + z * cosY;
        
        // Rotate around X axis (vertical camera rotation)
        const cosX = Math.cos(cameraRotation.x);
        const sinX = Math.sin(cameraRotation.x);
        const rotatedY = y * cosX - rotatedZ * sinX;
        const finalZ = y * sinX + rotatedZ * cosX;
        
        // Convert 3D world coordinates to 2D screen coordinates
        const screenX = window.innerWidth / 2 + rotatedX;
        const screenY = window.innerHeight / 2 - rotatedY;
        
        // Only show letters that are "in front" of the camera (negative Z)
        if (finalZ < 0) {
          letterData.element.style.left = screenX + 'px';
          letterData.element.style.top = screenY + 'px';
          letterData.element.style.display = 'block';
          
          // Scale based on distance (closer = bigger)
          const distance = Math.abs(finalZ);
          const scale = Math.max(0.3, Math.min(2.0, 300 / distance));
          letterData.element.style.transform = `scale(${scale})`;
        } else {
          // Hide letters that are "behind" the camera
          letterData.element.style.display = 'none';
        }
      });
    }

    function captureLetter(letter, index, element) {
      updateDebug(`Capturing: ${letter}`);
      
      if (captured.includes(index)) {
        updateDebug("Already captured");
        return;
      }
      
      captured.push(index);
      
      // Visual feedback
      element.classList.add('captured');
      
      // Haptic feedback
      if (navigator.vibrate) {
        navigator.vibrate(200);
      }
      
      // Remove after animation
      setTimeout(() => {
        if (element.parentNode) {
          element.parentNode.removeChild(element);
        }
        // Remove from letters array
        letters = letters.filter(l => l.index !== index);
        checkProgress();
      }, 1000);
    }

    function getTargetedLetter() {
      const crosshairX = window.innerWidth / 2;
      const crosshairY = window.innerHeight / 2;
      // Make targeting more forgiving on smaller screens
      const targetRadius = Math.max(60, Math.min(window.innerWidth, window.innerHeight) * 0.1);
      
      let closestLetter = null;
      let closestDistance = Infinity;
      
      letters.forEach(letterData => {
        if (captured.includes(letterData.index)) return;
        if (!letterData.element.parentNode) return;
        if (letterData.element.style.display === 'none') return;
        
        const letterRect = letterData.element.getBoundingClientRect();
        const letterCenterX = letterRect.left + letterRect.width / 2;
        const letterCenterY = letterRect.top + letterRect.height / 2;
        
        const distance = Math.sqrt(
          Math.pow(letterCenterX - crosshairX, 2) + 
          Math.pow(letterCenterY - crosshairY, 2)
        );
        
        if (distance <= targetRadius && distance < closestDistance) {
          closestDistance = distance;
          closestLetter = {
            letterData,
            distance
          };
        }
      });
      
      return closestLetter;
    }
    
    function updateTargetingFeedback() {
      const target = getTargetedLetter();
      const captureButton = document.getElementById('captureButton');
      const crosshair = document.getElementById('crosshair');
      
      // Remove targeted class from all letters
      letters.forEach(letterData => {
        if (letterData.element) {
          letterData.element.classList.remove('targeted');
        }
      });
      
      if (target) {
        captureButton.classList.add('ready');
        captureButton.textContent = `üéØ Capture ${target.letterData.letter}!`;
        crosshair.classList.add('target-locked');
        target.letterData.element.classList.add('targeted');
        
        // Light haptic feedback when targeting
        if (navigator.vibrate && !target.letterData.element.classList.contains('was-targeted')) {
          navigator.vibrate(50);
          target.letterData.element.classList.add('was-targeted');
        }
      } else {
        captureButton.classList.remove('ready');
        captureButton.textContent = 'üéØ Capture!';
        crosshair.classList.remove('target-locked');
        
        // Remove was-targeted class from all letters
        letters.forEach(letterData => {
          if (letterData.element) {
            letterData.element.classList.remove('was-targeted');
          }
        });
      }
    }
    
    // Update targeting feedback and debug info continuously
    setInterval(() => {
      updateTargetingFeedback();
      updateDebugInfo();
    }, 100);

    // Capture button with proper targeting
    document.getElementById('captureButton').addEventListener('click', () => {
      const target = getTargetedLetter();
      
      if (!target) {
        updateDebug("‚ùå No letter targeted! Point crosshair at a letter.");
        
        // Show helpful message
        const availableLetters = letters.filter(l => 
          !captured.includes(l.index) && 
          l.element.style.display !== 'none'
        ).map(l => l.letter).join(', ');
        
        if (availableLetters) {
          alert(`üéØ Point your crosshair at a letter!\n\nVisible letters: ${availableLetters}\n\nMove your device to center a letter in your crosshair.`);
        } else {
          alert("üì± No letters visible! Move your device around to find letters.");
        }
        return;
      }
      
      updateDebug(`‚úÖ Captured: ${target.letterData.letter}`);
      captureLetter(
        target.letterData.letter, 
        target.letterData.index, 
        target.letterData.element
      );
    });

    function checkProgress() {
      const wordDisplay = document.getElementById("targetWord");
      if (wordDisplay) {
        let displayWord = "";
        for (let i = 0; i < targetWord.length; i++) {
          displayWord += captured.includes(i) ? targetWord[i] : "_";
        }
        wordDisplay.textContent = displayWord;
        
        if (captured.length === targetWord.length) {
          // Celebration
          if (navigator.vibrate) {
            navigator.vibrate([200, 100, 200, 100, 200]);
          }
          
          setTimeout(() => {
            alert("üéâ Congratulations! You found: " + targetWord);
            
            // Reset game
            captured.length = 0;
            setTimeout(() => {
              createFloatingLetters();
            }, 1000);
          }, 500);
        }
      }
    }

    updateDebug("Script loaded - ready to start!");
  </script>
</body>
</html>
